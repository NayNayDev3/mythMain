{"version":3,"sources":["../../src/chain/IChainInterface.ts","../../src/chain/config.ts","../../src/errors/index.ts","../../src/wallet/index.ts","../../src/adapter/IAdapter.ts","../../src/walletConnectV1adapter.ts","../../src/utils.ts"],"names":["CHAIN_NAMESPACES","EIP155","SOLANA","ADAPTER_NAMESPACES","MULTICHAIN","DEFAULT_INFURA_ID","getChainConfig","finalChainId","chainId","parseInt","chainNamespace","getDefaultNetworkId","rpcTarget","displayName","blockExplorer","ticker","tickerName","getEvmChainConfig","getSolanaChainConfig","Web3AuthError","constructor","code","message","Object","value","toJSON","name","toString","JSON","CustomError","WalletInitializationError","fromCode","extraMessage","notFound","notInstalled","notReady","windowBlocked","windowClosed","incompatibleChainNameSpace","duplicateAdapterError","invalidProviderConfigError","providerNotReadyError","rpcConnectionError","invalidParams","invalidNetwork","WalletLoginError","connectionError","disconnectionError","notConnectedError","popupClosed","MULTI_CHAIN_ADAPTERS","OPENLOGIN","WALLET_CONNECT_V1","WALLET_CONNECT_V2","SOLANA_ADAPTERS","TORUS_SOLANA","PHANTOM","EVM_ADAPTERS","TORUS_EVM","METAMASK","WALLET_ADAPTERS","ADAPTER_CATEGORY","ADAPTER_STATUS","NOT_READY","READY","CONNECTING","CONNECTED","DISCONNECTED","ERRORED","ADAPTER_EVENTS","ADAPTER_DATA_UPDATED","BaseAdapter","chainConfigProxy","setChainConfig","customChainConfig","defaultChainConfig","setAdapterSettings","checkConnectionRequirements","checkInitializationRequirements","updateAdapterData","adapterName","data","SafeEventEmitter","options","uri","connected","provider","init","this","config","chainConfig","accounts","connect","adapter","reject","payload","resolve","log","error","getUserInfo","disconnect","cleanup","createNewSession","opts","forceNewSession","onConnectHandler","connectedChainId","hex","isHexStrict","reconnected","rehydrated","subscribeEvents","connector","getWalletConnectInstance","walletConnectOptions"],"mappings":"m3BAAaA,EAAmB,CAC9BC,OAD8B,SAE9BC,OAAQ,UAKGC,EAAkB,cAE7BC,WAAY,eCRDC,EAAoB,mCAgJpBC,EAAiB,cAC5B,IAAMC,EAAeC,EAAW,sBAAwCC,SAAQ,EAApD,IAhJDC,YAC3B,GAAIA,IAAmBV,EAAvB,OACE,SACK,GAAIU,IAAmBV,EAAvB,OACL,SAEF,MAAM,sCAAN,sBA0IiGW,CAAjG,GACA,OAAID,IAAmBV,EAAvB,OAxIgCQ,YAChC,IAAME,EAAiBV,EAAvB,OACA,WAAIQ,EACK,CACLE,iBACAF,QAFK,MAGLI,UAAS,uCAHJ,GAILC,YAJK,mBAKLC,cALK,wBAMLC,OANK,MAOLC,WAAY,YAET,IAAIR,EACF,CACLE,iBACAF,QAFK,MAGLI,UAAS,uCAHJ,GAILC,YAJK,UAKLC,cALK,gCAMLC,OANK,MAOLC,WAAY,YAET,IAAIR,EACF,CACLE,iBACAF,QAFK,MAGLI,UAAS,uCAHJ,GAILC,YAJK,UAKLC,cALK,gCAMLC,OANK,MAOLC,WAAY,YAET,IAAIR,EACF,CACLE,iBACAF,QAFK,MAGLI,UAAS,sCAHJ,GAILC,YAJK,SAKLC,cALK,+BAMLC,OANK,MAOLC,WAAY,YAET,KAAIR,EACF,CACLE,iBACAF,QAFK,OAGLI,UAAS,qCAHJ,GAILC,YAJK,QAKLC,cALK,8BAMLC,OANK,MAOLC,WAAY,YAET,MAAIR,EACF,CACLE,iBACAE,UAFK,0BAGLE,cAHK,0BAILN,QAJK,OAKLK,YALK,kBAMLE,OANK,QAOLC,WAAY,SAET,QAAIR,EACF,CACLE,iBACAE,UAFK,oCAGLE,cAHK,sCAILN,QAJK,UAKLK,YALK,yBAMLE,OANK,QAOLC,WAAY,SAET,KAAIR,EACF,CACLE,iBACAE,UAFK,mCAGLE,cAHK,sBAILN,QAJK,OAKLK,YALK,6BAMLE,OANK,MAOLC,WAAY,OAET,KAAIR,EACF,CACLE,iBACAE,UAFK,iDAGLE,cAHK,8BAILN,QAJK,OAKLK,YALK,6BAMLE,OANK,MAOLC,WAAY,OAIhB,KA2CSC,CAAP,GACSP,IAAmBV,EAAvB,OAzC4BQ,YACnC,IAAME,EAAiBV,EAAvB,OACA,WAAIQ,EACK,CACLE,iBACAI,cAFK,8BAGLN,QAHK,MAILK,YAJK,iBAKLD,UALK,sCAMLG,OANK,MAOLC,WAAY,gBAET,IAAIR,EACF,CACLI,UADK,iCAELE,cAFK,8CAGLN,QAHK,MAILE,iBACAG,YALK,UAMLE,OANK,MAOLC,WAAY,UAET,IAAIR,EACF,CACLI,UADK,gCAELE,cAFK,6CAGLN,QAHK,MAILE,iBACAG,YALK,SAMLE,OANK,MAOLC,WAAY,UAIhB,KAQSE,CAAP,GAGF,MC5IoBC,E,kDAKpBC,WAAmBC,EAAcC,oCAE/B,iB,uEAEA,SACA,UAAeA,GAAf,GAEAC,4CAAoC,CAAEC,MAAO,kBAPdF,E,0CAUjCG,WACE,MAAO,CACLC,KAAM,KADD,KAELL,KAAM,KAFD,KAGLC,QAAS,KAAKA,W,sBAIlBK,WACE,OAAOC,eAAe,KAAtB,c,GAxBwCC,KA4B/BC,E,kDAiBXV,WAAmBC,EAAcC,oCAE/B,mBAGAC,4CAAoC,CAAEC,MAAO,8BALdF,E,iDAQnBS,SAAQ,G,IAAeC,yDAAe,GAClD,OAAO,kBAAuCF,WAAvC,gBAAP,M,sBAIYG,W,IAASD,yDAAe,GACpC,OAAOF,gBAAP,K,0BAGYI,W,IAAaF,yDAAe,GACxC,OAAOF,gBAAP,K,sBAGYK,W,IAASH,yDAAe,GACpC,OAAOF,gBAAP,K,2BAGYM,W,IAAcJ,yDAAe,GACzC,OAAOF,gBAAP,K,0BAGYO,W,IAAaL,yDAAe,GACxC,OAAOF,gBAAP,K,wCAGYQ,W,IAA2BN,yDAAe,GACtD,OAAOF,gBAAP,K,mCAGYS,W,IAAsBP,yDAAe,GACjD,OAAOF,gBAAP,K,wCAGYU,W,IAA2BR,yDAAe,GACtD,OAAOF,gBAAP,K,mCAGYW,W,IAAsBT,yDAAe,GACjD,OAAOF,gBAAP,K,gCAGYY,W,IAAmBV,yDAAe,GAC9C,OAAOF,gBAAP,K,2BAGYa,W,IAAcX,yDAAe,GACzC,OAAOF,gBAAP,K,4BAGYc,W,IAAeZ,yDAAe,GAC1C,OAAOF,gBAAP,O,GA3E2CX,G,IAAlCW,aAC6B,CACtC,IADsC,SAEtC,KAFsC,sBAGtC,KAHsC,0BAItC,KAJsC,0BAKtC,KALsC,2BAMtC,KANsC,4CAOtC,KAPsC,wCAQtC,KARsC,oCAStC,KATsC,0BAUtC,KAVsC,4BAWtC,KAXsC,iCAYtC,KAZsC,2BAatC,KAAM,6B,IAqEGe,E,kDASXzB,WAAmBC,EAAcC,oCAE/B,mBAGAC,4CAAoC,CAAEC,MAAO,qBALdF,E,iDAQnBS,SAAQ,G,IAAeC,yDAAe,GAClD,OAAO,kBAA8Ba,WAA9B,WAAP,M,6BAGYC,W,IAAgBd,yDAAe,GAC3C,OAAOa,gBAAP,K,gCAGYE,W,IAAmBf,yDAAe,GAC9C,OAAOa,gBAAP,K,+BAGYG,W,IAAkBhB,yDAAe,GAC7C,OAAOa,gBAAP,K,yBAGYI,W,IAAYjB,yDAAe,GACvC,OAAOa,gBAAP,O,GAlCkC1B,G,qkBAAzB0B,aAC6B,CACtC,IADsC,SAEtC,KAFsC,gCAGtC,KAHsC,mCAItC,KAJsC,0BAKtC,KAAM,6C,IClIGK,EAAuB,CAClCC,UADkC,YAElCC,kBAFkC,oBAGlCC,kBAAmB,qBAGRC,EAAe,GAC1BC,aAD0B,eAE1BC,QAAS,WAFiB,GAMfC,EAAY,GACvBC,UADuB,YAEvBC,SAAU,YAFa,GAMZC,EAAe,a,qkBC2BfC,EAAmB,WAanBC,EAAiB,CAC5BC,UAD4B,YAE5BC,MAF4B,QAG5BC,WAH4B,aAI5BC,UAJ4B,YAK5BC,aAL4B,eAM5BC,QAAS,WAGEC,EAAc,cAEzBC,qBAAsB,yBAyBFC,E,2JACW,I,iCAImB,M,oDAY9CC,WACF,OAAO,sBAAwB,KAAxB,aAAP,O,4BAKFC,SAAc,GACZ,GAAI,cAAgBX,EAApB,OACA,IAAKY,EAAL,eAAuC,MAAM5C,WAAN,wDACvC,IAAM6C,EAAqBrE,EAAeoE,EAAD,eAAmCA,EAA5E,SACA,iC,gCAGFE,SAAkB,M,yCAElBC,WAEE,GAAI,YAAcjB,EAAd,mBAAmD,cAAgBE,EAAvE,YACK,GAAI,cAAgBA,EAApB,WAA+C,MAAMhC,WAAN,sBAEpD,GAAI,cAAgBgC,EAApB,UAA8C,MAAMjB,kBAAN,qBAC9C,GAAI,cAAgBiB,EAApB,MAA0C,MAAMjB,kBAAN,sC,6CAG5CiC,WACE,GAAI,cAAgBhB,EAApB,WACA,GAAI,cAAgBA,EAApB,UAA8C,MAAMhC,WAAN,qBAC9C,GAAI,cAAgBgC,EAApB,MAA0C,MAAMhC,WAAN,qC,+BAG5CiD,SAAiB,GACf,mBACA,UAAUV,EAAV,qBAA+C,CAAEW,YAAa,KAAf,KAA0BC,a,GAjDhCC,K,omBCjE7C,E,kDAuBE9D,uC,IAAY+D,yDAAyC,GAArD/D,OACE,e,0BAvBsBwC,EAAgBR,mB,sCAEUjD,EAAmBF,Q,2CAEhBD,EAAiBC,Q,0BAE/B4D,G,wEAIFC,EAAeC,W,iCAEV,CACxCqB,IAAK,K,+BAGkC,M,gCAEU,M,iCAE9B,GAInB,yBACA,cAAmBD,eAAnB,KAHF/D,E,2CAMIiE,W,MACF,QAAQ,UAAC,KAAD,yBAAC,EAAT,a,oBAGEC,W,MACF,OAAO,2DAAP,M,IAGEA,SAAQ,GACV,MAAM,UAAN,qB,yDAGIC,iFACJ,uEAAAC,MAAA,KAAAA,MACK,KAAL,cACE,iBAAmBlF,EAAeN,EAAD,OAAjC,IAGF,eAAiB,KAAjB,2BACA,gBAAkB,4BAA0B,CAAEyF,OAAQ,CAAEC,YAAa,KAAKA,eAE1E,UAAUrB,EAAV,MAAgCT,EAAhC,mBACA,YAAcE,EAAd,OACI,eAAJ,UAXIyB,wBAYF,mBAZEA,UAaI,sBAAsB,CAAEI,SAAU,eAAZ,SAAqCnF,QAAS,oCAbxE+E,iD,kHAiBAK,8FACJ,oFACK,KAAL,UAFIA,sBAEuB9D,WAAN,mCAFjB8D,WAIA,KAAJ,UAJIA,gCAKI,sBAAsB,CAAED,SAAU,eAAZ,SAAqCnF,QAAS,oCALxEoF,gCAMK,KAAP,UANEA,UASA,cAAgB9B,EAApB,WATI8B,wBAYF,UAAI,oBAAJ,8BAAI,EAAJ,cACE,eAAiB,KAAjB,4BAbAA,UAeI,KAAN,mBAfEA,QAgBF,YAAc9B,EAAd,WACA,UAAUO,EAAV,WAAqC,CAAEwB,QAASjC,EAAgBR,oBAjB9DwC,iCAmBG,aAAY,cACjB,IAAK,EAAL,UAAqB,OAAOE,EAAOhE,WAAd,oCAErB,oDAAkC,qFAChC,SAAcgC,EAAd,MACA,OAAUO,EAAV,MAAgCT,EAAhC,mBAFgC,kBAGzBkC,EAAO,UAAd,uBAHgC,4CAKlC,IAEE,gEAA6B,wFAC3B,GACE,OAAUzB,EAAV,WAFyB,SAIrB,mBAAsB0B,SAA5B,IAJ2B,gCAKpBC,EAAQ,EAAf,WAL2B,2CAA7B,oCAAAR,KAAA,gBAOA,SACAS,6DADuB,GAGvB,SAAcnC,EAAd,MACA,gBACA,OAAUO,EAAV,WACAyB,EACEI,iBAEIrD,kEAA0E,eAAe,IAAf,qBAHhFiD,WA1CAF,iD,sHAmDAO,iFACC,KAAL,UADIA,sBACuBtD,oBAAN,yDADjBsD,gCAEJ,IAFIA,gD,qHAKAC,qGAAWjB,iCAAgC,CAAEkB,SAAS,GAClDA,EAAR,EAAQA,QACH,KAAD,WAAoB,KAAxB,UAFID,sBAE0CvD,oBAAN,6BAFpCuD,uBAGE,eAAN,cAHIA,OAIJ,mBACA,GACE,oBACA,YAActC,EAAd,UACA,sBAGA,YAAcA,EAAd,MAEF,UAAUO,EAAV,cAbI+B,gD,2HAgBQE,gHAAiBC,iCAAqC,CAAEC,iBAAiB,GAChF,KAAL,UADYF,sBACexE,WAAN,mCADTwE,WAERC,oBAAwB,eAA5B,QAFYD,gCAGJ,eAAN,cAHUA,UAMZ,UAAI,KAAJ,uCAAI,EAAJ,+BAAI,EAAJ,YANYA,iCAOJ,6BAA6B,CAAE9F,QAASC,UAAS,2DAAD,YAP5C6F,kEAYL,aAAkB,c,MACvB,IAAK,EAAL,UAAqB,OAAOR,EAAOhE,WAAd,oCACrBmE,8DACA,oEAAiC,6FAC/B,EAD+B,uBAE7B,OAAU5B,EAAV,QAAkCxB,kBAAlC,6CAF6B,kBAGtBiD,EAAP,IAH6B,cAKzBV,EAAMW,SAAZ,GACA,oBAAuB,CAAEX,QAEzB,yDAR+B,kBASxBY,KATwB,2CAAjC,yDAYA,0BAA6B,CAAExF,QAASC,UAAS,wDAAD,YAAhD,OAAmGyF,YAGjG,OAFAD,+DACA,OAAU5B,EAAV,WACOyB,EAAP,UA9BQQ,iD,2HAmCAG,WAAgB,GAAhBA,4EACP,KAAD,WAAoB,KAAxB,WADYA,sBACmC3E,WAAN,mCAD7B2E,UAEP,KAAL,YAFYA,sBAEiB3E,gBAAN,2BAFX2E,UAIJjG,EAAR,EAAQA,QACRyF,kCACMS,EAAmBjG,SAAQ,ECvK3B,kBADkBkG,EDwKmBC,ICvKtC,kBAA4B,IAA4B,0BAA/D,GDuKE,GAA2CA,OAClBnG,SAAS,iBAAD,QAAjC,IAPYgG,kCAUJ,sBAAsB,CAAED,iBAAiB,IAVrCC,eAWV,UACEpC,EADF,QAEEvC,qEAEiD0D,KAAA,YAFjD1D,gCAFF,kDAXU2E,4CAoBN,8BAA8B,KAApC,WApBYA,QAqBZ,qBAAqB,KAArB,WACA,YAAc3C,EAAd,UACA,UAAUO,EAAV,UAAoC,CAAEwB,QAASjC,EAAX,kBAA8CiD,YAAa,KAAKC,aAvBxFL,kCClKYE,QDkKZF,Y,oFA0BNM,SAAe,cACrBC,6DAA+B,+EAC7B,GACE,OAAU3C,EAAV,WAF2B,2CAA/B2C,yD,sCAOMC,WACN,IAAMC,EAAuB,qCAA7B,GAGA,OAFAA,SAA8BA,UAA9BA,mCAEO,QAAP,O,GA3MJ","file":"static/js/19.12823cc1.chunk.js","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { CustomError } from 'ts-custom-error';\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst CHAIN_NAMESPACES = {\n  EIP155: \"eip155\",\n  SOLANA: \"solana\"\n};\nconst ADAPTER_NAMESPACES = _objectSpread$2(_objectSpread$2({}, CHAIN_NAMESPACES), {}, {\n  MULTICHAIN: \"multichain\"\n});\n\nconst DEFAULT_INFURA_ID = \"776218ac4734478c90191dde8cae483c\";\n\nconst getDefaultNetworkId = chainNamespace => {\n  if (chainNamespace === CHAIN_NAMESPACES.EIP155) {\n    return 1;\n  } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {\n    return 1;\n  }\n\n  throw new Error(\"Chain namespace \".concat(chainNamespace, \" is not supported\"));\n};\n\nconst getEvmChainConfig = chainId => {\n  const chainNamespace = CHAIN_NAMESPACES.EIP155;\n\n  if (chainId === 1) {\n    return {\n      chainNamespace,\n      chainId: \"0x1\",\n      rpcTarget: \"https://mainnet.infura.io/v3/\".concat(DEFAULT_INFURA_ID),\n      displayName: \"Ethereum Mainnet\",\n      blockExplorer: \"https://etherscan.io/\",\n      ticker: \"ETH\",\n      tickerName: \"Ethereum\"\n    };\n  } else if (chainId === 3) {\n    return {\n      chainNamespace,\n      chainId: \"0x3\",\n      rpcTarget: \"https://ropsten.infura.io/v3/\".concat(DEFAULT_INFURA_ID),\n      displayName: \"ropsten\",\n      blockExplorer: \"https://ropsten.etherscan.io/\",\n      ticker: \"ETH\",\n      tickerName: \"Ethereum\"\n    };\n  } else if (chainId === 4) {\n    return {\n      chainNamespace,\n      chainId: \"0x4\",\n      rpcTarget: \"https://rinkeby.infura.io/v3/\".concat(DEFAULT_INFURA_ID),\n      displayName: \"rinkeby\",\n      blockExplorer: \"https://rinkeby.etherscan.io/\",\n      ticker: \"ETH\",\n      tickerName: \"Ethereum\"\n    };\n  } else if (chainId === 5) {\n    return {\n      chainNamespace,\n      chainId: \"0x5\",\n      rpcTarget: \"https://goerli.infura.io/v3/\".concat(DEFAULT_INFURA_ID),\n      displayName: \"goerli\",\n      blockExplorer: \"https://goerli.etherscan.io/\",\n      ticker: \"ETH\",\n      tickerName: \"Ethereum\"\n    };\n  } else if (chainId === 42) {\n    return {\n      chainNamespace,\n      chainId: \"0x2a\",\n      rpcTarget: \"https://kovan.infura.io/v3/\".concat(DEFAULT_INFURA_ID),\n      displayName: \"kovan\",\n      blockExplorer: \"https://kovan.etherscan.io/\",\n      ticker: \"ETH\",\n      tickerName: \"Ethereum\"\n    };\n  } else if (chainId === 137) {\n    return {\n      chainNamespace,\n      rpcTarget: \"https://polygon-rpc.com\",\n      blockExplorer: \"https://polygonscan.com\",\n      chainId: \"0x89\",\n      displayName: \"Polygon Mainnet\",\n      ticker: \"matic\",\n      tickerName: \"matic\"\n    };\n  } else if (chainId === 80001) {\n    return {\n      chainNamespace,\n      rpcTarget: \"https://rpc-mumbai.maticvigil.com\",\n      blockExplorer: \"https://mumbai-explorer.matic.today\",\n      chainId: \"0x13881\",\n      displayName: \"Polygon Mumbai Testnet\",\n      ticker: \"matic\",\n      tickerName: \"matic\"\n    };\n  } else if (chainId === 56) {\n    return {\n      chainNamespace,\n      rpcTarget: \"https://bsc-dataseed.binance.org\",\n      blockExplorer: \"https://bscscan.com\",\n      chainId: \"0x38\",\n      displayName: \"Binance SmartChain Mainnet\",\n      ticker: \"BNB\",\n      tickerName: \"BNB\"\n    };\n  } else if (chainId === 97) {\n    return {\n      chainNamespace,\n      rpcTarget: \"https://data-seed-prebsc-2-s3.binance.org:8545\",\n      blockExplorer: \"https://testnet.bscscan.com\",\n      chainId: \"0x61\",\n      displayName: \"Binance SmartChain Testnet\",\n      ticker: \"BNB\",\n      tickerName: \"BNB\"\n    };\n  }\n\n  return null;\n};\nconst getSolanaChainConfig = chainId => {\n  const chainNamespace = CHAIN_NAMESPACES.SOLANA;\n\n  if (chainId === 1) {\n    return {\n      chainNamespace,\n      blockExplorer: \"https://explorer.solana.com\",\n      chainId: \"0x1\",\n      displayName: \"Solana Mainnet\",\n      rpcTarget: \"https://api.mainnet-beta.solana.com\",\n      ticker: \"SOL\",\n      tickerName: \"Solana Token\"\n    };\n  } else if (chainId === 2) {\n    return {\n      rpcTarget: \"https://api.testnet.solana.com\",\n      blockExplorer: \"https://explorer.solana.com?cluster=testnet\",\n      chainId: \"0x2\",\n      chainNamespace,\n      displayName: \"testnet\",\n      ticker: \"SOL\",\n      tickerName: \"solana\"\n    };\n  } else if (chainId === 3) {\n    return {\n      rpcTarget: \"https://api.devnet.solana.com\",\n      blockExplorer: \"https://explorer.solana.com?cluster=devnet\",\n      chainId: \"0x3\",\n      chainNamespace,\n      displayName: \"devnet\",\n      ticker: \"SOL\",\n      tickerName: \"solana\"\n    };\n  }\n\n  return null;\n};\nconst getChainConfig = (chainNamespace, chainId) => {\n  const finalChainId = chainId ? typeof chainId === \"number\" ? chainId : parseInt(chainId, 16) : getDefaultNetworkId(chainNamespace);\n\n  if (chainNamespace === CHAIN_NAMESPACES.EIP155) {\n    return getEvmChainConfig(finalChainId);\n  } else if (chainNamespace === CHAIN_NAMESPACES.SOLANA) {\n    return getSolanaChainConfig(finalChainId);\n  }\n\n  return null;\n};\n\nclass Web3AuthError extends CustomError {\n  constructor(code, message) {\n    // takes care of stack and proto\n    super(message);\n\n    _defineProperty(this, \"code\", void 0);\n\n    _defineProperty(this, \"message\", void 0);\n\n    this.code = code;\n    this.message = message || \"\"; // Set name explicitly as minification can mangle class names\n\n    Object.defineProperty(this, \"name\", {\n      value: \"Web3AuthError\"\n    });\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message\n    };\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n\n}\nclass WalletInitializationError extends Web3AuthError {\n  constructor(code, message) {\n    // takes care of stack and proto\n    super(code, message); // Set name explicitly as minification can mangle class names\n\n    Object.defineProperty(this, \"name\", {\n      value: \"WalletInitializationError\"\n    });\n  }\n\n  static fromCode(code) {\n    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return new WalletInitializationError(code, \"\".concat(WalletInitializationError.messages[code], \", \").concat(extraMessage));\n  } // Custom methods\n\n\n  static notFound() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5001, extraMessage);\n  }\n\n  static notInstalled() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5002, extraMessage);\n  }\n\n  static notReady() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5003, extraMessage);\n  }\n\n  static windowBlocked() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5004, extraMessage);\n  }\n\n  static windowClosed() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5005, extraMessage);\n  }\n\n  static incompatibleChainNameSpace() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5006, extraMessage);\n  }\n\n  static duplicateAdapterError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5007, extraMessage);\n  }\n\n  static invalidProviderConfigError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5008, extraMessage);\n  }\n\n  static providerNotReadyError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5009, extraMessage);\n  }\n\n  static rpcConnectionError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5010, extraMessage);\n  }\n\n  static invalidParams() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5011, extraMessage);\n  }\n\n  static invalidNetwork() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletInitializationError.fromCode(5013, extraMessage);\n  }\n\n}\n/**\n * wallet login errors\n */\n\n_defineProperty(WalletInitializationError, \"messages\", {\n  5000: \"Custom\",\n  5001: \"Wallet is not found\",\n  5002: \"Wallet is not installed\",\n  5003: \"Wallet is not ready yet\",\n  5004: \"Wallet window is blocked\",\n  5005: \"Wallet window has been closed by the user\",\n  5006: \"Incompatible chain namespace provided\",\n  5007: \"Adapter has already been included\",\n  5008: \"Invalid provider Config\",\n  5009: \"Provider is not ready yet\",\n  5010: \"Failed to connect with rpc url\",\n  5011: \"Invalid params passed in\",\n  5013: \"Invalid network provided\"\n});\n\nclass WalletLoginError extends Web3AuthError {\n  constructor(code, message) {\n    // takes care of stack and proto\n    super(code, message); // Set name explicitly as minification can mangle class names\n\n    Object.defineProperty(this, \"name\", {\n      value: \"WalletLoginError\"\n    });\n  }\n\n  static fromCode(code) {\n    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return new WalletLoginError(code, \"\".concat(WalletLoginError.messages[code]).concat(extraMessage));\n  }\n\n  static connectionError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletLoginError.fromCode(5111, extraMessage);\n  }\n\n  static disconnectionError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletLoginError.fromCode(5112, extraMessage);\n  }\n\n  static notConnectedError() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletLoginError.fromCode(5113, extraMessage);\n  }\n\n  static popupClosed() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return WalletLoginError.fromCode(5114, extraMessage);\n  }\n\n}\n\n_defineProperty(WalletLoginError, \"messages\", {\n  5000: \"Custom\",\n  5111: \"Failed to connect with wallet\",\n  5112: \"Failed to disconnect from wallet\",\n  5113: \"Wallet is not connected\",\n  5114: \"Wallet popup has been closed by the user\"\n});\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nconst MULTI_CHAIN_ADAPTERS = {\n  OPENLOGIN: \"openlogin\",\n  WALLET_CONNECT_V1: \"wallet-connect-v1\",\n  WALLET_CONNECT_V2: \"wallet-connect-v2\"\n};\nconst SOLANA_ADAPTERS = _objectSpread$1({\n  TORUS_SOLANA: \"torus-solana\",\n  PHANTOM: \"phantom\"\n}, MULTI_CHAIN_ADAPTERS);\nconst EVM_ADAPTERS = _objectSpread$1({\n  TORUS_EVM: \"torus-evm\",\n  METAMASK: \"metamask\"\n}, MULTI_CHAIN_ADAPTERS);\nconst WALLET_ADAPTERS = _objectSpread$1(_objectSpread$1({}, EVM_ADAPTERS), SOLANA_ADAPTERS);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst ADAPTER_CATEGORY = {\n  EXTERNAL: \"external\",\n  IN_APP: \"in_app\"\n};\nconst ADAPTER_STATUS = {\n  NOT_READY: \"not_ready\",\n  READY: \"ready\",\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  ERRORED: \"errored\"\n};\nconst ADAPTER_EVENTS = _objectSpread(_objectSpread({}, ADAPTER_STATUS), {}, {\n  ADAPTER_DATA_UPDATED: \"adapter_data_updated\"\n});\nclass BaseAdapter extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"adapterData\", {});\n\n    _defineProperty(this, \"chainConfig\", null);\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  setChainConfig(customChainConfig) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    if (!customChainConfig.chainNamespace) throw WalletInitializationError.notReady(\"ChainNamespace is required while setting chainConfig\");\n    const defaultChainConfig = getChainConfig(customChainConfig.chainNamespace, customChainConfig.chainId);\n    this.chainConfig = _objectSpread(_objectSpread({}, defaultChainConfig), customChainConfig);\n  }\n\n  setAdapterSettings(_) {}\n\n  checkConnectionRequirements() {\n    // we reconnect without killing existing wallet connect session on calling connect again.\n    if (this.name === WALLET_ADAPTERS.WALLET_CONNECT_V1 && this.status === ADAPTER_STATUS.CONNECTING) return;else if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already connecting\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletLoginError.connectionError(\"Already connected\");\n    if (this.status !== ADAPTER_STATUS.READY) throw WalletLoginError.connectionError(\"Wallet adapter is not ready yet\");\n  }\n\n  checkInitializationRequirements() {\n    if (this.status === ADAPTER_STATUS.NOT_READY) return;\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  updateAdapterData(data) {\n    this.adapterData = data;\n    this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, {\n      adapterName: this.name,\n      data\n    });\n  }\n\n}\n\nconst PROVIDER_EVENTS = {\n  INITIALIZED: \"initialized\",\n  ERRORED: \"errored\"\n};\n\nfunction storageAvailable(type) {\n  let storageExists = false;\n  let storageLength = 0;\n  let storage;\n\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (error) {\n    const _error = error;\n    return !!(_error && ( // everything except Firefox\n    _error.code === 22 || // Firefox\n    _error.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    _error.name === \"QuotaExceededError\" || // Firefox\n    _error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0);\n  }\n}\nconst isHexStrict = hex => {\n  return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n\nexport { ADAPTER_CATEGORY, ADAPTER_EVENTS, ADAPTER_NAMESPACES, ADAPTER_STATUS, BaseAdapter, CHAIN_NAMESPACES, DEFAULT_INFURA_ID, EVM_ADAPTERS, MULTI_CHAIN_ADAPTERS, PROVIDER_EVENTS, SOLANA_ADAPTERS, WALLET_ADAPTERS, WalletInitializationError, WalletLoginError, Web3AuthError, getChainConfig, getEvmChainConfig, getSolanaChainConfig, isHexStrict, storageAvailable };\n//# sourceMappingURL=base.esm.js.map\n",null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError, isHexStrict } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\"\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        this.connector = this.getWalletConnectInstance();\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$2;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId\", chainId);\n    const connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n    if (connectedChainId !== parseInt(this.chainConfig.chainId, 16)) {\n      // we need to create a new session since old session is already used and\n      // user needs to login again with correct chain with new qr code.\n      await this.createNewSession({\n        forceNewSession: true\n      });\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(connectedChainId, \", Please switch to correct chain from wallet\")));\n      return;\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n",null],"sourceRoot":""}